import math
import random
import decimal
import sympy
import math

def modInverse(a, m) :
    a = a % m;
    for x in range(1, m) :
        if ((a * x) % m == 1) :
            return x
    return 1

def primRoots(modulo, cmul, nroots):
  roots = []
  hit   = 0
  for g in range(1, modulo) :
    if (hit == nroots) :
      break
    else :
      for powers in range (1, modulo) :
        pow_mod = pow(g, powers) % modulo
        if (pow_mod == 1) :
          if (powers == modulo-1) :
            if (pow(g, cmul) < modulo) :
              roots.append(pow(g, cmul))
              hit = hit + 1
          else :
            break
  return roots




#-------------------------------------------------------
#Below is fixed to size of N that hardware supports
#-------------------------------------------------------
NSIZE     = int(128)
DWIDTH    = int(128)
POLYDEG   = int(4096)

#--------------------Global variables---------------------------
#Find a prime number P = const_mul * (2**log2POLYDEG) + 1
log2polydeg = int(math.log(POLYDEG, 2))
const_mul = 3 # for 4096
#const_mul = 1 # for 256
#const_mul = 24 # for 512
nroot     = 1 # Exit after finding nroot
modulus = const_mul * 2**log2polydeg + 1
invpolydeg = modInverse(POLYDEG, modulus)
print("-----Modulus, Nth Root of Unity and Selected Nth root of unity-----------")
print("Modulus :", modulus)
print("-----Finding the Nth (N = POLYDEG) root of unity for the above modulus-----------")
primitive_roots = primRoots(modulus, const_mul, nroot)
print("Primitive root of unity :", primitive_roots)
nth_rou = primitive_roots[0]
print("Selected Nth Root of Unity", nth_rou)
print("--------------------------------------------------------------------------")
#--------------------------------------------------------------


#-------------------------------------------------------
#All the variables with fhe_ prefix will be programmed
#in CCS0301 hardware
#------------------------------------------------------
fhe_N        = modulus
fhe_NINV     = invpolydeg
                                            #VN corrector is used to unbias the random number generated by hardware RNG

#-------------------------------------------------------
#Derive other values to be programmed from above
#-------------------------------------------------------


fhe_log2ofN    = math.ceil(math.log(fhe_N, 2))
fhe_ctl2       = int(fhe_log2ofN)



print ("#------------------------------------------------------------------")
print ("#INFO: Initial Values")
print ("#------------------------------------------------------------------")
print ("INFO: Value of Modulus         := %s" % fhe_N)
print ("INFO: Value of NINV            := %s" % fhe_NINV)
print ("INFO: Value of LOG2(modulus)   := %d" % int(fhe_log2ofN))
print ("#------------------------------------------------------------------")

#--------------------------------------------------------------------
#Convert the values to be programmed to hexadecimal of required size
#--------------------------------------------------------------------
fhe_N                = "{0:#0{1}x}".format(int(fhe_N),int(NSIZE/4)+2)
fhe_NINV             = "{0:#0{1}x}".format(int(fhe_NINV),int(NSIZE/4)+2)
fhe_log2ofN          = "{0:#0{1}x}".format(int(fhe_log2ofN),12+2)
fhe_polydeg          = "{0:#0{1}x}".format(int(POLYDEG),4+2)
print(fhe_N)

with open('params.data', 'w') as fout:
    fout.write( '{}\n'.format(fhe_N) )
    fout.write( '{}\n'.format(fhe_NINV) )
    fout.write( '{}\n'.format(fhe_log2ofN) )
    fout.write( '{}\n'.format(fhe_polydeg) )

lst = list(range(modulus-1))
seq   = random.sample(lst, POLYDEG)
seq2  = random.sample(lst, POLYDEG)
fseq  = random.sample(lst, POLYDEG)
fseq2 = random.sample(lst, POLYDEG)
ftwdl = random.sample(lst, POLYDEG)
tempdata = random.sample(lst, POLYDEG)
with open('fseq.data', 'w') as fout1:
    with open('fseq2.data', 'w') as fout2:
        with open('ftwdl.data', 'w') as foutt:
            for i in range(POLYDEG):
                fseq[i]  = "{0:#0{1}x}".format(int(seq[i]), int(NSIZE/4)+2)
                fseq2[i] = "{0:#0{1}x}".format(int(seq2[i]),int(NSIZE/4)+2)
                ftwdl[i] = "{0:#0{1}x}".format(int((nth_rou**i)%modulus), int(NSIZE/4)+2)
                fout1.write( '{}\n'.format(fseq[i]) )
                fout2.write( '{}\n'.format(fseq2[i]) )
                foutt.write( '{}\n'.format(ftwdl[i]) )
